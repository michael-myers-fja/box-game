<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Box</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        canvas {
            background: #eee;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>

<body>

    <canvas id="myCanvas" width="480" height="320"></canvas>
    <div id="controls">
        <span> P1: <input id="p1" name="p1"/></span>
        <span> P2: <input id="p2" name="p2"/></span>
        <button id="submit" onclick="formsubmit()">Submit</button>
    </div>

    <script>
        const LINE_WIDTH = 3;
        const CANVAS_MARGIN = 0;


        function Edge(p1, p2) {
            this.ends = [p1, p2]
            this.faces = []
            this.owner = null
        }
        function Face() {
            this.edges = []
            this.owner = null
        }

        function Board(pointWidth, pointHeight) {
            this.width = pointWidth
            this.height = pointHeight
            this.edgePool = {}

            this.getEdge = function (p1, p2) {
                if (!this.edgePool[p1])
                    this.edgePool[p1] = {}
                if (!this.edgePool[p2])
                    this.edgePool[p2] = {}

                if (!this.edgePool[p1][p2]) {
                    var newEdge = new Edge(p1, p2)
                    this.edgePool[p1][p2] = newEdge
                    this.edgePool[p2][p1] = newEdge
                }

                return this.edgePool[p1][p2]
            }

            // init board
            for (var h = 0; h < this.height - 1; h++) {
                for (var w = 0; w < this.width - 1; w++) {
                    var box = new Face();
                    // layout ex:
                    // a--b
                    // |  |
                    // d--c
                    var a = (this.width * h) + w
                    var b = a + 1
                    var c = b + this.width
                    var d = c - 1

                    var ab = this.getEdge(a, b)
                    box.edges.push(ab)
                    ab.faces.push(box)

                    var bc = this.getEdge(b, c)
                    box.edges.push(bc)
                    bc.faces.push(box)

                    var cd = this.getEdge(c, d)
                    box.edges.push(cd)
                    cd.faces.push(box)

                    var da = this.getEdge(d, a)
                    box.edges.push(da)
                    da.faces.push(box)
                }
            }
        }

        function mapPointToScreen(point, board, ctx) {
            var xFactor = (point % board.width) / board.width
            var yFactor = (Math.trunc(point / board.width)) / board.height

            const canvas = ctx.canvas
            const boxSize = getBoxScreenSize(canvas, board)
            return {
                x: canvas.clientWidth * xFactor + boxSize.x / 2,
                y: canvas.clientHeight * yFactor + boxSize.y / 2
            }
        }

        function getBoxScreenSize(canvas, board) {
            return {
                x: canvas.clientWidth / board.width,
                y: canvas.clientHeight / board.height
            }
        }
        function getScreenMargin(boxSize) {
            return {
                x: boxSize.x / 2,
                y: boxSize.y / 2
            }
        }

        function mapScreenToEdge(sp, board, canvas) {
            const boxSize = getBoxScreenSize(canvas, board)
            const margin = getScreenMargin(boxSize)
            // factors represent a percentage in board coordinates
            const xFactor = (sp.x - margin.x) / (canvas.clientWidth - boxSize.x)
            const yFactor = (sp.y - margin.y) / (canvas.clientHeight - boxSize.y)
            console.log("xFactor:" + xFactor + " yFactor:" + yFactor)

            // ratios are the scaled board coordinate
            const xRatio = xFactor * (board.width - 1), yRatio = yFactor * (board.height - 1)
            console.log("Ratio: " + xRatio + ", " + yRatio)

            // round is the nearest actual coordinate
            const xRound = Math.round(xRatio), yRound = Math.round(yRatio)
            console.log("Rounded: " + xRound + ", " + yRound)

            var p1, p2
            // check if mouse is closer to a horizontal or vertical edge, then translate to edge endpoints.
            console.log("x: " + Math.abs(xRound - xRatio) + " vs y: " + Math.abs(yRound - yRatio))
            if (Math.abs(yRound - yRatio) < Math.abs(xRound - xRatio)) {
                p1 = yRound * board.width + Math.floor(xRatio)
                p2 = p1 + 1
            } else {
                p1 = Math.floor(yRatio) * board.width + xRound
                p2 = p1 + board.width
            }
            // with the endpoints, the edge obj can be pulled from the edge pool
            return board.getEdge(p1, p2)
        }


        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: clamp(evt.clientX - rect.left, 0, rect.right),
                y: clamp(evt.clientY - rect.top, 0, rect.bottom)
            };
        }
        function clamp(n, min, max) {
            return Math.min(Math.max(n, min), max)
        }

        function draw(ctx, board) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            var toVisit = [0]
            var alreadyDrawn = []
            while (toVisit.length > 0) {
                // draw current point
                var p = toVisit.shift()
                var sp = mapPointToScreen(p, board, ctx)
                drawPoint(ctx, sp)
                alreadyDrawn.push(p)

                // queue next points
                var endpoints = Object.keys(board.edgePool[p])

                endpoints.forEach(function (endP) {
                    var edge = board.edgePool[p][endP]
                    if (alreadyDrawn.indexOf(edge) < 0) {
                        var spA = sp
                        var spB = mapPointToScreen(endP, board, ctx)
                        drawEdge(ctx, spA, spB, edge.owner)
                        alreadyDrawn.push(edge)
                    }
                    if (alreadyDrawn.indexOf(endP) < 0 && toVisit.indexOf(endP) < 0) {
                        // if not processed or queued, queue it endpoint
                        toVisit.push(endP)
                    }
                })
            }

        }

        function drawPoint(ctx, sp) {
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, 5, 0, Math.PI * 2, false);
            ctx.fillStyle = "#D0D0D0";
            ctx.fill();
            ctx.closePath();
        }

        function drawEdge(ctx, spA, spB, owner) {
            var w = .1
            ctx.beginPath()
            ctx.moveTo(spA.x, spA.y)
            ctx.strokeStyle = owner ? "#000000" : "#D0D0D0";
            ctx.lineWidth = LINE_WIDTH;
            ctx.lineTo(spB.x, spB.y)
            ctx.stroke()
            ctx.closePath()
        }

        function formsubmit(event) {
            var p1Input = document.getElementById("p1").value;
            var p2Input = document.getElementById("p2").value;
            console.log("P1: "+p1Input+" P2: "+p2Input);
        }
        
        const board = new Board(12, 8)
        var ctx = document.getElementById("myCanvas").getContext("2d");
        ctx.canvas.addEventListener('click', function (evt) {
            const mousePos = getMousePos(ctx.canvas, evt)
            const edge = mapScreenToEdge(mousePos, board, ctx.canvas)
            edge.owner = "player"
            console.log(edge)
            draw(ctx, board)
        }, false);

        draw(ctx, board)

    </script>

</body>

</html>